<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>符智生</title>
  
  <subtitle>永远相信美好的事情即将来临</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xigqo.cn/"/>
  <updated>2019-05-13T08:12:05.000Z</updated>
  <id>http://xigqo.cn/</id>
  
  <author>
    <name>符智生</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://xigqo.cn/2019/05/13/The%20Kth%20node%20of%20the%20last%20list%20of%20the%20single%20list/"/>
    <id>http://xigqo.cn/2019/05/13/The Kth node of the last list of the single list/</id>
    <published>2019-05-13T08:11:16.516Z</published>
    <updated>2019-05-13T08:12:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="输出单链表倒数第-K-个节点"><a href="#输出单链表倒数第-K-个节点" class="headerlink" title="输出单链表倒数第 K 个节点"></a>输出单链表倒数第 K 个节点</h1><h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h5><blockquote><p>输入一个单链表，输出此链表中的倒数第 K 个节点。（去除头结点，节点计数从 1 开始）。 </p></blockquote><h5 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a><strong>双指针法</strong></h5><p>解题思想</p><p>（1）定义两个指针 p1 和 p2 分别指向链表头节点。<br>（2）p1 前进 K 个节点，则 p1 与 p2 相距 K 个节点。<br>（3）p1，p2 同时前进，每次前进 1 个节点。<br>（4）当 p1 指向到达链表末尾，由于 p1 与 p2 相距 K 个节点，则 p2 指向目标节点。</p><h5 id="图解过程"><a href="#图解过程" class="headerlink" title="图解过程"></a><strong>图解过程</strong></h5><p><img src="https://img-blog.csdnimg.cn/20190327104653877.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fZnpz,size_16,color_FFFFFF,t_70" alt="img"> </p><p><img src="https://img-blog.csdnimg.cn/20190327104722438.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fZnpz,size_16,color_FFFFFF,t_70" alt="img"> </p><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a><strong>代码实现</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ListNode* findKthTail(ListNode *pHead, <span class="keyword">int</span> K)&#123;</span><br><span class="line">    <span class="keyword">if</span> (NULL == pHead || K == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> NULL;</span><br><span class="line">    <span class="comment">//p1，p2均指向头节点</span></span><br><span class="line">    ListNode *p1 = pHead;</span><br><span class="line">    ListNode *p2 = pHead;</span><br><span class="line">    <span class="comment">//p1先出发，前进K个节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; K; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p1)<span class="comment">//防止k大于链表节点的个数</span></span><br><span class="line">            p1 = p1-&gt;_next;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> NULL;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (p1)<span class="comment">//如果p1没有到达链表结尾，则p1，p2继续遍历</span></span><br><span class="line">    &#123;</span><br><span class="line">        p1 = p1-&gt;_next;</span><br><span class="line">        p2 = p2-&gt;_next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p2;<span class="comment">//当p1到达末尾时，p2正好指向倒数第K个节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;输出单链表倒数第-K-个节点&quot;&gt;&lt;a href=&quot;#输出单链表倒数第-K-个节点&quot; class=&quot;headerlink&quot; title=&quot;输出单链表倒数第 K 个节点&quot;&gt;&lt;/a&gt;输出单链表倒数第 K 个节点&lt;/h1&gt;&lt;h5 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://xigqo.cn/2019/05/13/array/"/>
    <id>http://xigqo.cn/2019/05/13/array/</id>
    <published>2019-05-13T08:04:58.440Z</published>
    <updated>2019-05-13T08:04:34.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="给出一个数组，求出现次数最多的那个数字及其出现次数"><a href="#给出一个数组，求出现次数最多的那个数字及其出现次数" class="headerlink" title="给出一个数组，求出现次数最多的那个数字及其出现次数"></a>给出一个数组，求出现次数最多的那个数字及其出现次数</h1><p>用HashMap&lt;Integer, Integer&gt;,数组元素做key，出现次数做value;遍历数组，出现一次，value++； 代码： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class CountNumber&#123;</span><br><span class="line">  </span><br><span class="line">    public static void mian(String[] args)&#123;</span><br><span class="line">        int[] arr = &#123;1,2,3,4,8,2,2,5,3,1,2,4,5,2&#125;</span><br><span class="line">        int[] ans = maxTimsx(arr);</span><br><span class="line">        System.out.println(&quot;数字：&quot; + ans[0] + &quot;出现&quot; + ans[1] + &quot;次&quot;)</span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    public static int[] maxTimes(int[] arr)&#123;</span><br><span class="line">        if(arr == null || arr.length &lt; 1)&#123;</span><br><span class="line">                return null;</span><br><span class="line">        &#125;</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;Integer,Integer&gt;();</span><br><span class="line">        </span><br><span class="line">        int times = 0;</span><br><span class="line">        int number = 0;</span><br><span class="line"> </span><br><span class="line">        for(i=0;i&lt;arr.length;i++)&#123;</span><br><span class="line">            if(map.get(arr.[i]) == null)&#123;</span><br><span class="line">                map.put(arr[i],1)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            integer value = map.get(arr[i]) + 1;</span><br><span class="line">            map.put(arr[i],value)</span><br><span class="line">            if(value &gt; times)&#123;</span><br><span class="line">                times = value;</span><br><span class="line">                number = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        return new int[] &#123;number,times&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;给出一个数组，求出现次数最多的那个数字及其出现次数&quot;&gt;&lt;a href=&quot;#给出一个数组，求出现次数最多的那个数字及其出现次数&quot; class=&quot;headerlink&quot; title=&quot;给出一个数组，求出现次数最多的那个数字及其出现次数&quot;&gt;&lt;/a&gt;给出一个数组，求出现次
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://xigqo.cn/2019/05/13/hhh/"/>
    <id>http://xigqo.cn/2019/05/13/hhh/</id>
    <published>2019-05-13T06:51:18.148Z</published>
    <updated>2019-05-13T06:51:18.148Z</updated>
    
    <content type="html"><![CDATA[<p>hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh<br>hhhhhhhhhhhhhhhhh</p><p>###hhhhhhhhhhhhhhh</p><p>#hhhhhhhhhhhhh</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh&lt;br&gt;hhhhhhhhhhhhhhhhh&lt;/p&gt;
&lt;p&gt;###hhhhhhhhhhhhhhh&lt;/p&gt;
&lt;p&gt;#hhhhhhhhhhhhh&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
</feed>
