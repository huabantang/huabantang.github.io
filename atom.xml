<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>符智生</title>
  
  <subtitle>永远相信美好的事情即将来临</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xigqo.cn/"/>
  <updated>2019-05-13T08:26:21.000Z</updated>
  <id>http://xigqo.cn/</id>
  
  <author>
    <name>符智生</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://xigqo.cn/2019/05/13/Determine%20if%20the%20linked%20list%20has%20a%20ring/"/>
    <id>http://xigqo.cn/2019/05/13/Determine if the linked list has a ring/</id>
    <published>2019-05-13T08:26:07.868Z</published>
    <updated>2019-05-13T08:26:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>title: 判断链表是否有环</p><p>tags: 算法</p><p>-–</p><p><img src="https://images.unsplash.com/flagged/photo-1556669546-b1f29875df1c?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;w=1000&amp;q=80" alt="img"> </p><h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h5><blockquote><p>判断链表是否有环</p><p>单链表中的环是指链表末尾的节点的 next 指针不为 NULL ，而是指向了链表中的某个节点，导致链表中出现了环形结构。</p></blockquote><h5 id="快慢指针法"><a href="#快慢指针法" class="headerlink" title="快慢指针法"></a><strong>快慢指针法</strong></h5><p>解题思想 </p><blockquote><p>（1）定义两个指针分别为 slow，fast，并且将指针均指向链表头节点。 </p><p>（2）规定，slow 指针每次前进 1 个节点，fast 指针每次前进两个节点。 </p><p>（3）当 slow 与 fast 相等，且二者均不为空，则链表存在环。 </p></blockquote><h5 id="图解过程："><a href="#图解过程：" class="headerlink" title="图解过程："></a><strong>图解过程：</strong></h5><p>无环过程： </p><p><img src="https://img-blog.csdnimg.cn/20190327105121671.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fZnpz,size_16,color_FFFFFF,t_70" alt="img"> </p><p><img src="https://img-blog.csdnimg.cn/20190327105143473.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fZnpz,size_16,color_FFFFFF,t_70" alt="img"> </p><p><img src="https://img-blog.csdnimg.cn/20190327105206876.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fZnpz,size_16,color_FFFFFF,t_70" alt="img"> </p><p>通过图解过程可以看出，若表中不存在环形，fast 与 slow 指针只能在链表末尾相遇。</p><p>有环过程：</p><p><img src="https://img-blog.csdnimg.cn/20190327105256322.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fZnpz,size_16,color_FFFFFF,t_70" alt="img"> </p><p><img src="https://img-blog.csdnimg.cn/2019032710532455.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fZnpz,size_16,color_FFFFFF,t_70" alt="img"> <img src="https://img-blog.csdnimg.cn/20190327105348498.png" alt="img"> </p><p>图解过程可以看出，若链表中存在环，则快慢指针必然能在环中相遇。这就好比在环形跑道中进行龟兔赛跑。由于兔子速度大于乌龟速度，则必然会出现兔子与乌龟再次相遇情况。因此，当出现快慢指针相等时，且二者不为NULL，则表明链表存在环。 </p><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a><strong>代码实现</strong></h5><pre><code class="java">bool isExistLoop(ListNode* pHead)  {      ListNode* fast;//慢指针，每次前进一个节点    ListNode* slow;//快指针，每次前进2个节点     slow = fast = pHead ;  //两个指针均指向链表头节点    //当没有到达链表结尾，则继续前进    while (slow != NULL &amp;&amp; fast -&gt; next != NULL)  {          slow = slow -&gt; next ; //慢指针前进一个节点        fast = fast -&gt; next -&gt; next ; //快指针前进两个节点        if (slow == fast)  //若两个指针相遇，且均不为NULL则存在环            return true ;      }      //到达末尾仍然没有相遇，则不存在环    return false ;  }</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;title: 判断链表是否有环&lt;/p&gt;
&lt;p&gt;tags: 算法&lt;/p&gt;
&lt;p&gt;-–&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.unsplash.com/flagged/photo-1556669546-b1f29875df1c?ixlib=rb-1.2
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://xigqo.cn/2019/05/13/The%20Kth%20node%20of%20the%20last%20list%20of%20the%20single%20list/"/>
    <id>http://xigqo.cn/2019/05/13/The Kth node of the last list of the single list/</id>
    <published>2019-05-13T08:26:07.480Z</published>
    <updated>2019-05-13T08:27:25.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://images.unsplash.com/photo-1553901753-215db344677a?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;w=1000&amp;q=80" alt="aerial photography of mountain covered with fog"> </p><h1 id="输出单链表倒数第-K-个节点"><a href="#输出单链表倒数第-K-个节点" class="headerlink" title="输出单链表倒数第 K 个节点"></a>输出单链表倒数第 K 个节点</h1><h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h5><blockquote><p>输入一个单链表，输出此链表中的倒数第 K 个节点。（去除头结点，节点计数从 1 开始）。 </p></blockquote><h5 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a><strong>双指针法</strong></h5><p>解题思想</p><p>（1）定义两个指针 p1 和 p2 分别指向链表头节点。<br>（2）p1 前进 K 个节点，则 p1 与 p2 相距 K 个节点。<br>（3）p1，p2 同时前进，每次前进 1 个节点。<br>（4）当 p1 指向到达链表末尾，由于 p1 与 p2 相距 K 个节点，则 p2 指向目标节点。</p><h5 id="图解过程"><a href="#图解过程" class="headerlink" title="图解过程"></a><strong>图解过程</strong></h5><p><img src="https://img-blog.csdnimg.cn/20190327104653877.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fZnpz,size_16,color_FFFFFF,t_70" alt="img"> </p><p><img src="https://img-blog.csdnimg.cn/20190327104722438.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fZnpz,size_16,color_FFFFFF,t_70" alt="img"> </p><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a><strong>代码实现</strong></h5><pre><code class="java">ListNode* findKthTail(ListNode *pHead, int K){    if (NULL == pHead || K == 0)        return NULL;    //p1，p2均指向头节点    ListNode *p1 = pHead;    ListNode *p2 = pHead;    //p1先出发，前进K个节点    for (int i = 0; i &lt; K; i++) {        if (p1)//防止k大于链表节点的个数            p1 = p1-&gt;_next;        else            return NULL;    }    while (p1)//如果p1没有到达链表结尾，则p1，p2继续遍历    {        p1 = p1-&gt;_next;        p2 = p2-&gt;_next;    }    return p2;//当p1到达末尾时，p2正好指向倒数第K个节点}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://images.unsplash.com/photo-1553901753-215db344677a?ixlib=rb-1.2.1&amp;amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;amp;w=1000&amp;amp;q=80&quot; alt
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://xigqo.cn/2019/05/13/array/"/>
    <id>http://xigqo.cn/2019/05/13/array/</id>
    <published>2019-05-13T08:04:58.440Z</published>
    <updated>2019-05-13T08:04:34.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="给出一个数组，求出现次数最多的那个数字及其出现次数"><a href="#给出一个数组，求出现次数最多的那个数字及其出现次数" class="headerlink" title="给出一个数组，求出现次数最多的那个数字及其出现次数"></a>给出一个数组，求出现次数最多的那个数字及其出现次数</h1><p>用HashMap&lt;Integer, Integer&gt;,数组元素做key，出现次数做value;遍历数组，出现一次，value++； 代码： </p><pre><code>public class CountNumber{    public static void mian(String[] args){        int[] arr = {1,2,3,4,8,2,2,5,3,1,2,4,5,2}        int[] ans = maxTimsx(arr);        System.out.println(&quot;数字：&quot; + ans[0] + &quot;出现&quot; + ans[1] + &quot;次&quot;)    }      public static int[] maxTimes(int[] arr){        if(arr == null || arr.length &lt; 1){                return null;        }        HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;Integer,Integer&gt;();        int times = 0;        int number = 0;        for(i=0;i&lt;arr.length;i++){            if(map.get(arr.[i]) == null){                map.put(arr[i],1)            }        }else{            integer value = map.get(arr[i]) + 1;            map.put(arr[i],value)            if(value &gt; times){                times = value;                number = arr[i];            }        }        return new int[] {number,times};    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;给出一个数组，求出现次数最多的那个数字及其出现次数&quot;&gt;&lt;a href=&quot;#给出一个数组，求出现次数最多的那个数字及其出现次数&quot; class=&quot;headerlink&quot; title=&quot;给出一个数组，求出现次数最多的那个数字及其出现次数&quot;&gt;&lt;/a&gt;给出一个数组，求出现次
      
    
    </summary>
    
    
  </entry>
  
</feed>
