<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>两数之和</title>
      <link href="/2019/05/13/Two_Sum/"/>
      <url>/2019/05/13/Two_Sum/</url>
      
        <content type="html"><![CDATA[<h1 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h1><blockquote><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p></blockquote><h5 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h5><blockquote><p>给定 nums = [2, 7, 11, 15], target = 9<br>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]</p></blockquote><p>这是<strong>两数之和</strong>的问题，看似很简单，读者可以先思考下如何实现。本文介绍三种实现方式，并且分析复杂度。 </p><h5 id="1-暴力法"><a href="#1-暴力法" class="headerlink" title="1. 暴力法"></a>1. 暴力法</h5><p>遍历每个元素 xx，并查找是否存在一个值与 target - xtarget−x 相等的目标元素。代码示例如下：</p><pre><code class="java">public int[] twoSum(int[] nums, int target) {       int[] result = new int[2];       for(int i = 0; i &lt; nums.length; i++) {           for(int j = i + 1; j &lt; nums.length; j++) {               if(nums[i] + nums[j] == target) {                   result[0] = i;                   result[1] = j;                   return result;               }           }       }       return result;}</code></pre><p><strong>算法复杂度分析</strong>： </p><blockquote><p>时间复杂度：O(n^2)，空间复杂度：O(1)</p><p>对于每个元素，我们试图通过遍历数组的其余部分来寻找它所对应的目标元素，这将耗费 O(n) 的时间，因此时间复杂度为 O(n^2)。</p></blockquote><h5 id="2-两遍哈希表"><a href="#2-两遍哈希表" class="headerlink" title="2. 两遍哈希表"></a>2. 两遍哈希表</h5><p>为了对时间复杂度进行优化，我们需要更有效的方法来检查数组中是否存在目标元素。如果存在，我们需要找出它的索引。</p><p>保持数组中的每个元素与其索引相互对应的最好方法是什么？哈希表。</p><p>通过以空间换取速度的方式，我们可以将查找时间从 O(n) 降低到 O(1)。</p><p>哈希表正是为此目的而构建的，它支持以近似恒定的时间进行快速查找。</p><p>我用“近似”来描述，是因为一旦出现冲突，查找用时可能会退化到 O(n)。</p><p>但只要你仔细地挑选哈希函数，在哈希表中进行查找的用时应当被摊销为 O(1)。</p><p>一个简单的实现使用了两次迭代。在第一次迭代中，我们将每个元素的值和它的索引添加到表中。</p><p>然后，在第二次迭代中，我们将检查每个元素所对应的目标元素（target - nums[i]）是否存在于表中。</p><p>注意，该目标元素不能是 nums[i] 本身！</p><pre><code class="java">public int[] twoSum(int[] nums, int target) {   Mapmap = new HashMap&lt;&gt;();   for (int i = 0; i &lt; nums.length; i++) {       map.put(nums[i], i);   }   for (int i = 0; i &lt; nums.length; i++) {       int complement = target - nums[i];       if (map.containsKey(complement) &amp;&amp; map.get(complement) != i) {           return new int[] { i, map.get(complement) };       }   }   throw new IllegalArgumentException(&quot;No two sum solution&quot;);}</code></pre><h5 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a><strong>复杂度分析</strong>：</h5><blockquote><p>时间复杂度：O(n)， 我们把包含有 n 个元素的列表遍历两次。由于哈希表将查找时间缩短到 O(1) ，所以时间复杂度为 O(n)。</p><p>空间复杂度：O(n)， 所需的额外空间取决于哈希表中存储的元素数量，该表中存储了 n  个元素。</p></blockquote><h5 id="3-一遍哈希表"><a href="#3-一遍哈希表" class="headerlink" title="3. 一遍哈希表"></a>3. 一遍哈希表</h5><p>事实证明，我们可以一次完成。在进行迭代并将元素插入到表中的同时，我们还会回过头来检查表中是否已经存在当前元素所对应的目标元素。</p><p>如果它存在，那我们已经找到了对应解，并立即将其返回。</p><pre><code class="java">public int[] twoSum(int[] nums, int target) {   Mapmap = new HashMap&lt;&gt;();   for (int i = 0; i &lt; nums.length; i++) {       int complement = target - nums[i];       if (map.containsKey(complement)) {           return new int[] { map.get(complement), i };       }       map.put(nums[i], i);   }   throw new IllegalArgumentException(&quot;No two sum solution&quot;);}</code></pre><h5 id="复杂度分析：-1"><a href="#复杂度分析：-1" class="headerlink" title="复杂度分析："></a><strong>复杂度分析</strong>：</h5><blockquote><p>时间复杂度：O(n)， 我们只遍历了包含有 nn 个元素的列表一次。在表中进行的每次查找只花费 O(1) 的时间。</p><p>空间复杂度：O(n)， 所需的额外空间取决于哈希表中存储的元素数量，该表最多需要存储 n 个元素。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>判断链表是否有环</title>
      <link href="/2019/05/13/Determine_if_the_linked_list_has_a_ring/"/>
      <url>/2019/05/13/Determine_if_the_linked_list_has_a_ring/</url>
      
        <content type="html"><![CDATA[<h1 id="判断链表是否有环"><a href="#判断链表是否有环" class="headerlink" title="判断链表是否有环"></a>判断链表是否有环</h1><h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h5><blockquote><p>判断链表是否有环</p><p>单链表中的环是指链表末尾的节点的 next 指针不为 NULL ，而是指向了链表中的某个节点，导致链表中出现了环形结构。</p></blockquote><h5 id="快慢指针法"><a href="#快慢指针法" class="headerlink" title="快慢指针法"></a><strong>快慢指针法</strong></h5><p>解题思想 </p><blockquote><p>（1）定义两个指针分别为 slow，fast，并且将指针均指向链表头节点。 </p><p>（2）规定，slow 指针每次前进 1 个节点，fast 指针每次前进两个节点。 </p><p>（3）当 slow 与 fast 相等，且二者均不为空，则链表存在环。 </p></blockquote><h5 id="图解过程："><a href="#图解过程：" class="headerlink" title="图解过程："></a><strong>图解过程：</strong></h5><p>无环过程： </p><p><img src="https://img-blog.csdnimg.cn/20190327105121671.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fZnpz,size_16,color_FFFFFF,t_70" alt="img"> </p><p><img src="https://img-blog.csdnimg.cn/20190327105143473.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fZnpz,size_16,color_FFFFFF,t_70" alt="img"> </p><p><img src="https://img-blog.csdnimg.cn/20190327105206876.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fZnpz,size_16,color_FFFFFF,t_70" alt="img"> </p><p>通过图解过程可以看出，若表中不存在环形，fast 与 slow 指针只能在链表末尾相遇。</p><p>有环过程：</p><p><img src="https://img-blog.csdnimg.cn/20190327105256322.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fZnpz,size_16,color_FFFFFF,t_70" alt="img"> </p><p><img src="https://img-blog.csdnimg.cn/2019032710532455.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fZnpz,size_16,color_FFFFFF,t_70" alt="img"> <img src="https://img-blog.csdnimg.cn/20190327105348498.png" alt="img"> </p><p>图解过程可以看出，若链表中存在环，则快慢指针必然能在环中相遇。这就好比在环形跑道中进行龟兔赛跑。由于兔子速度大于乌龟速度，则必然会出现兔子与乌龟再次相遇情况。因此，当出现快慢指针相等时，且二者不为NULL，则表明链表存在环。 </p><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a><strong>代码实现</strong></h5><pre><code class="java">bool isExistLoop(ListNode* pHead)  {      ListNode* fast;//慢指针，每次前进一个节点    ListNode* slow;//快指针，每次前进2个节点     slow = fast = pHead ;  //两个指针均指向链表头节点    //当没有到达链表结尾，则继续前进    while (slow != NULL &amp;&amp; fast -&gt; next != NULL)  {          slow = slow -&gt; next ; //慢指针前进一个节点        fast = fast -&gt; next -&gt; next ; //快指针前进两个节点        if (slow == fast)  //若两个指针相遇，且均不为NULL则存在环            return true ;      }      //到达末尾仍然没有相遇，则不存在环    return false ;  }</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>给出一个数组，求出现次数最多的那个数字及其出现次数</title>
      <link href="/2019/05/13/Find_the_number_of_occurrences_in_the_array%20and_the_number_of_occurrences/"/>
      <url>/2019/05/13/Find_the_number_of_occurrences_in_the_array%20and_the_number_of_occurrences/</url>
      
        <content type="html"><![CDATA[<h1 id="给出一个数组，求出现次数最多的那个数字及其出现次数"><a href="#给出一个数组，求出现次数最多的那个数字及其出现次数" class="headerlink" title="给出一个数组，求出现次数最多的那个数字及其出现次数"></a>给出一个数组，求出现次数最多的那个数字及其出现次数</h1><p>用HashMap&lt;Integer, Integer&gt;,数组元素做key，出现次数做value;遍历数组，出现一次，value++； 代码： </p><pre><code>public class CountNumber{    public static void mian(String[] args){        int[] arr = {1,2,3,4,8,2,2,5,3,1,2,4,5,2}        int[] ans = maxTimsx(arr);        System.out.println(&quot;数字：&quot; + ans[0] + &quot;出现&quot; + ans[1] + &quot;次&quot;)    }      public static int[] maxTimes(int[] arr){        if(arr == null || arr.length &lt; 1){                return null;        }        HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;Integer,Integer&gt;();        int times = 0;        int number = 0;        for(i=0;i&lt;arr.length;i++){            if(map.get(arr.[i]) == null){                map.put(arr[i],1)            }        }else{            integer value = map.get(arr[i]) + 1;            map.put(arr[i],value)            if(value &gt; times){                times = value;                number = arr[i];            }        }        return new int[] {number,times};    }}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>输出单链表倒数第 K 个节点</title>
      <link href="/2019/05/13/Output_the_singly_linked_list_to_the_Kth_node/"/>
      <url>/2019/05/13/Output_the_singly_linked_list_to_the_Kth_node/</url>
      
        <content type="html"><![CDATA[<h1 id="输出单链表倒数第-K-个节点"><a href="#输出单链表倒数第-K-个节点" class="headerlink" title="输出单链表倒数第 K 个节点"></a>输出单链表倒数第 K 个节点</h1><h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h5><blockquote><p>输入一个单链表，输出此链表中的倒数第 K 个节点。（去除头结点，节点计数从 1 开始）。 </p></blockquote><h5 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a><strong>双指针法</strong></h5><p>解题思想</p><p>（1）定义两个指针 p1 和 p2 分别指向链表头节点。<br>（2）p1 前进 K 个节点，则 p1 与 p2 相距 K 个节点。<br>（3）p1，p2 同时前进，每次前进 1 个节点。<br>（4）当 p1 指向到达链表末尾，由于 p1 与 p2 相距 K 个节点，则 p2 指向目标节点。</p><h5 id="图解过程"><a href="#图解过程" class="headerlink" title="图解过程"></a><strong>图解过程</strong></h5><p><img src="https://img-blog.csdnimg.cn/20190327104653877.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fZnpz,size_16,color_FFFFFF,t_70" alt="img"> </p><p><img src="https://img-blog.csdnimg.cn/20190327104722438.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fZnpz,size_16,color_FFFFFF,t_70" alt="img"> </p><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a><strong>代码实现</strong></h5><pre><code class="java">ListNode* findKthTail(ListNode *pHead, int K){    if (NULL == pHead || K == 0)        return NULL;    //p1，p2均指向头节点    ListNode *p1 = pHead;    ListNode *p2 = pHead;    //p1先出发，前进K个节点    for (int i = 0; i &lt; K; i++) {        if (p1)//防止k大于链表节点的个数            p1 = p1-&gt;_next;        else            return NULL;    }    while (p1)//如果p1没有到达链表结尾，则p1，p2继续遍历    {        p1 = p1-&gt;_next;        p2 = p2-&gt;_next;    }    return p2;//当p1到达末尾时，p2正好指向倒数第K个节点}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
